# 单例模式

## 1、单例的创建方式

### a、饿汉式

###### 在类初识化时直接创建一个实例，不会存在重复创建的问题，但是对象的生命周期过长，浪费内存空间；

### b、懒汉式

###### 	在调用的时候，才给对象进行初始化，延时加载，多线程情况下无法保证单例，会有线程安全问题；

###### 	解决方案：加锁。直接在方法上加锁，会导致性能低下；在方法内部加锁进行判断，即双重校验；

###### 	优化：使用静态内部类的方式，不会有安全问题，又可以延时加载；

### c、枚举式

###### 	通过枚举创建对象，既可以保证安全问题，又不会有性能问题；

### d、容器式

###### 	spring中使用的方式，把对象保存到map中，再根据唯一key进行获取，会有线程安全问题，可以通过synchronized进行处理；

### e、threadlocal方式

###### 	通过threadlocal创建单例，在单线程下可以保证对象唯一，多线程下会创建多个对象；



## 2、单例的攻击方式

### a、反射

###### 	描述：反射可以通过强制访问，调用私有的无参构造器创建类的实例，调用多次可以创建多个对象，无法保证单例；

###### 	应对：在私有构造器中进行判断，防止对象被多次创建。枚举式单例中，jdk已经做了限制，没有无参构造器，有参构造器无法通过反射创建对象；

### b、序列化

###### 	描述：对象被序列化保存，再通过反序列化读取时，会获取到一个新的实例，无法保证单例；

###### 	应对：重写一个readResolve方法，反序列化时，会判断是否存在这个方法，如果存在就通过反射调用这个方法，覆盖反序列化出的对象，从而保证单例；枚举式单例中，通过类似容器式单例的方法来保证对象唯一。
